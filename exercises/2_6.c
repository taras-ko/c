/* 		2.6 Напишите функцию setbits(x, p, n, y) так, чтобы она возвращала аргумент x 
	в котором n битов, начиная с позиции p, равны n крайним правым битам аргу-
 	мента y, а остальные не тронуты.
		2.7 Напишите функцию invert(x,p,n), возвращающую свой аргумент x, в котором обращены n бит
 	начиная с позиции p (т.е. единичные биты заменены нулевыми и наоборот), а остальные нетронуты*/
#include <stdio.h>

int setbits(int x, int p, int n, int y);
int invert(int x, int p, int n);

main()
{
	//printf("x: %x\n", setbits(0xfff, 8, 4, 0x5));

	printf("x: %x\n", setbits(0xfff, 8, 4));
	return 0;
}
int invert(int x, int p, int n)
{
	int m, m1, z;
	m = ~(~0 << n) << p - n + 1; // 0...01...10...0
	m1 = ~m;
	z = x;
    x = x & m1; //xxxx000000xxxx;	

	z = ~z;
	z =z & m;

	x = x | z;
}
int setbits(int x, int p, int n, int y) //2.6
{
	int m;
	/*	под готовим маску m, которую будем конкатенировать с
	  	y, для того, чтобы вычленить n крайних правых битов 
	  	~0 - состоит целиком из двоичных 1
	 	~0 << n - сдвиг в лево заполняющий нулями
	 	~() - инверсия */	
	m = ~(~0 << n);
	y = y & m; // вычленим n крайних битов 
	y = y << p - n; //cдвинем чтобы потом "вкрапливать" в x 

	/*	теперь обнулим в x разряды, начиная с p'го по p - n + 1
	 	сдвинем маску на p - n + 1 вправо и применим поразрядное
	 	дополнение до 1 - ~*/
	m = ~(m << p - n); // учитывая, что + - выше приритетом чем << 
	x = x & m; // конкатенация обнуляет биты в x

	x = x | y; // вкрапление y в x
	return x;
}
